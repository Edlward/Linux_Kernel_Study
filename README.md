# Linux_Kernel_Study
linux kernel&driver study

# 1 HelloWorld
a simple module<br>

# 2 mem-malloc
内存管理<br>
### 物理地址：
>>被CPU放在地址总线上，简单理解为地址总线上使用的地址<br>
### 逻辑地址：
>>硬件平台**段式管理**转换前的地址<br>
### 线性地址：
>>硬件平台**页式管理**转换前的地址，又名虚拟地址<br>
<程序代码产生出的是逻辑地址><br>
CPU利用段式内存管理单元，将逻辑地址转换为线性地址，再利用页式内存管理单元，把线性地址最终转换为物理地址<br>
### 段式管理：
>>16位CPU为了能够访问1M的内存空间，CPU就才用了内存分段的管理模式，并在CPU内部加入了段寄存器。<br>
>>16位CPU把1M内存空间分为若干个逻辑段，每个逻辑段的要求如下：<br>
>>1)、逻辑段的起始地址（段地址）必须是16的倍数，即最后4个二进制位必须全为0；<br>
>>2)、逻辑段的最大容量为64K，这是由16位寄存器的寻址空间所决定。<br>

>>**`物理地址PA = 段寄存器的值 * 16(或左移4位) + 偏移量`**<br>

32位cpu内存管理仍然采用“分段”的管理模式，不同之处是32位CPU采用了两种工作模式：`实模式`和`保护模式`<br>
#### 实模式：<br>
>>32位和16位微机是一致的。<br>
#### 保护模式：<br>
>>段基地址可以长达32位，每个段的最大容量可达到4G，段寄存器的值是表示段地址的“选择器”，用该选择器可以从内存中得到一个32位的段地址，存储单元的物理地址就是该段地址加上段内偏移量，这与16位微机的物理地址计算方式完全不同。<br>
	
### 页式管理：
>>负责把线性地址最终翻译成一个物理地址。<br>
>>从管理和效率的角度出发，线性地址被分为以固定长度为单位的组，成为“页（page）”，例如一个32位的机器，线性地址最大为4G，可以用4KB为一个页来划分，这样整个线性地址就被划分为一个table_page[2^20]的大数组，共有2的20次方个页，这个大数组我们称之为页目录。目录中的每一个目录项，就是一个地址--对应的页的地址。<br>
### 每一个32位的线性地址被划分为三个部分：
>>页目录索引(10位)：页表索引(10位)：偏移(12位)<br>
### 依据以下步骤进行地址转换：
>>1、装入进程的页目录地址(操作系统在调度进程时，把这个地址装入CR3)；<br>
>>2、根据线性地址前十位，在页目录数组中，找到对应的索引项，页目录中的项是一个页表的地址；<br>
>>3、根据线性地址的中间十位，在页表数组中找到页的起始地址；<br>
>>4、将页的起始地址与线性地址中最后12位相加，得到物理地址。<br>
页目录共有：2^10项，也就是说有这个多个页表，每个页表又对应了2^10个页，每个页中可寻址2^12个字节，那么这样的二级模式能够覆盖2^32=4G的物理地址空间。<br>
`linux逻辑地址和线性地址指的是同一个地址，巧妙的绕过了段机制，而完全利用了分页机制`<br>

```c
order = get_order(8192);
buf = __get_free_pages(GFP_KERNEL,order);
//order是2的幂数,即order=0,是一页,order=1是两页,order=2,是四页,order=3是八页
free_pages(buf2,order);
```
# 3 kernel list
内核链表<br>
[list head详解](https://blog.csdn.net/yong199105140/article/details/8234089?locationNum=4&fps=1)<br>
[list_head结构体的理解](https://blog.csdn.net/u013904227/article/details/50931540)<br>








